/*******************************************************************************
 * Copyright (c)  Maxprograms.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-v10.html
 *
 * Contributors:
 *     Maxprograms - initial API and implementation
 *******************************************************************************/
package com.maxprograms.converters;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.xml.parsers.ParserConfigurationException;

import com.maxprograms.xml.Document;
import com.maxprograms.xml.SAXBuilder;

import org.json.JSONObject;
import org.xml.sax.SAXException;

public class FileFormats {

	private FileFormats() {
		// do not instantiate this class
	}

	public static final String INX = "Adobe InDesign Interchange";
	public static final String ICML = "Adobe InCopy ICML";
	public static final String IDML = "Adobe InDesign IDML";
	public static final String DITA = "DITA Map";
	public static final String HTML = "HTML Page";
	public static final String JS = "JavaScript";
	public static final String JSON = "JSON";
	public static final String JAVA = "Java Properties";
	public static final String MIF = "MIF (Maker Interchange Format)";
	public static final String OFF = "Microsoft Office 2007 Document";
	public static final String OO = "OpenOffice Document";
	public static final String TEXT = "Plain Text";
	public static final String PO = "PO (Portable Objects)";
	public static final String RC = "RC (Windows C/C++ Resources)";
	public static final String RESX = "ResX (Windows .NET Resources)";
	public static final String SDLPPX = "Trados Studio Package";
	public static final String SDLXLIFF = "SDLXLIFF Document";
	public static final String SRT = "SRT Subtitle";
	public static final String TS = "TS (Qt Linguist translation source)";
	public static final String TXML = "TXML Document";
	public static final String WPML = "WPML XLIFF";
	public static final String XLIFF = "XLIFF Document";
	public static final String XML = "XML Document";
	public static final String XMLG = "XML (Generic)";

	protected static final String[] formats = { INX, ICML, IDML, DITA, HTML, JS, JSON, JAVA, MIF, OFF, OO, TEXT, PO, RC,
			RESX, SDLPPX, SDLXLIFF, SRT, TS, TXML, WPML, XLIFF, XML, XMLG };

	public static boolean isBilingual(String type) {
		return Arrays.asList(PO, SDLPPX, SDLXLIFF, TS, TXML, WPML, XLIFF).contains(type);
	}

	public static String detectFormat(String fileName) {
		File file = new File(fileName);
		if (!file.exists()) {
			return null;
		}
		try {
			byte[] array = new byte[40960];
			try (FileInputStream input = new FileInputStream(file)) {
				if (input.read(array) == -1) {
					throw new IOException("Premature end of file");
				}
			}
			String string = "";

			Charset bom = EncodingResolver.getBOM(fileName);

			if (bom != null) {
				byte[] efbbbf = { -17, -69, -65 }; // UTF-8
				String utf8 = new String(efbbbf);
				string = new String(array, bom);
				if (string.startsWith("\uFFFE")) {
					string = string.substring("\uFFFE".length());
				} else if (string.startsWith("\uFEFF")) {
					string = string.substring("\uFEFF".length());
				} else if (string.startsWith(utf8)) {
					string = string.substring(utf8.length());
				}
			} else {
				string = new String(array);
			}

			if (string.startsWith("<MIFFile")) {
				return MIF;
			}

			if (string.indexOf("<xliff ") != -1 && string.indexOf("xmlns:sdl") != -1) {
				return SDLXLIFF;
			}
			if (string.indexOf("<xliff ") != -1 && string.indexOf("<![CDATA[") != -1) {
				return WPML;
			}
			if (string.indexOf("<xliff ") != -1 && parseXliff(fileName)) {
				return XLIFF;
			}
			if (string.startsWith("<?xml")) {
				if (string.indexOf("<txml ") != -1) {
					return TXML;
				}
				if (string.indexOf("<docu") != -1 && string.indexOf("<?aid ") != -1) {
					return INX;
				}
				if (string.indexOf("xmlns:msdata") != -1 && string.indexOf("<root") != -1) {
					return RESX;
				}
				if (string.indexOf("!DOCTYPE TS>") != -1) {
					return TS;
				}
				if (string.indexOf("<map") != -1 || string.indexOf("<bookmap") != -1) {
					return DITA;
				}
				if (string.indexOf("<?aid ") != -1 || string.indexOf("<Document ") != -1) {
					return ICML;
				}
				return XML;
			}
			if (string.startsWith("<svg")) {
				return XML;
			}
			if (string.indexOf("<!DOCTYPE TS>") != -1) {
				return TS;
			}
			if (string.startsWith("<!DOCTYPE")) {
				int index = string.indexOf("-//IETF//DTD HTML");
				if (index != -1) {
					return HTML;
				}
				index = string.indexOf("-//W3C//DTD HTML");
				if (index != -1) {
					return HTML;
				}
				index = string.indexOf(" html");
				if (index != -1) {
					return HTML;
				}
				return XML;
			}
			if (string.indexOf("msgid") != -1 && string.indexOf("msgstr") != -1) {
				return PO;
			}
			int index = string.toLowerCase().indexOf("<html");
			if (index != -1) {
				return HTML;
			}

			if (string.startsWith("PK")) {
				// might be a zipped file
				boolean openOffice = false;
				boolean hasXML = false;
				boolean idml = false;
				boolean sdlppx = false;
				try (ZipInputStream in = new ZipInputStream(new FileInputStream(file))) {
					ZipEntry entry = null;
					while ((entry = in.getNextEntry()) != null) {
						if (entry.getName().equals("content.xml")) {
							openOffice = true;
							break;
						}
						if (entry.getName().equals("designmap.xml")) {
							idml = true;
							break;
						}
						if (entry.getName().endsWith((".sdlproj"))) {
							sdlppx = true;
							break;
						}
						if (entry.getName().matches(".*\\.xml")) {
							hasXML = true;
						}
					}
				}
				if (idml) {
					return IDML;
				}
				if (openOffice) {
					return OO;
				}
				if (sdlppx) {
					return SDLPPX;
				}
				if (hasXML) {
					return OFF;
				}
			}
			if (string.indexOf("#include") != -1 || string.indexOf("#define") != -1 || string.indexOf("DIALOG") != -1
					|| string.indexOf("DIALOGEX") != -1 || string.indexOf("MENU") != -1
					|| string.indexOf("MENUEX") != -1 || string.indexOf("POPUP") != -1
					|| string.indexOf("STRINGTABLE") != -1 || string.indexOf("AUTO3STATE") != -1
					|| string.indexOf("AUTOCHECKBOX") != -1 || string.indexOf("AUTORADIOBUTTON") != -1
					|| string.indexOf("CHECKBOX") != -1 || string.indexOf("COMBOBOX") != -1
					|| string.indexOf("CONTROL") != -1 || string.indexOf("CTEXT") != -1
					|| string.indexOf("DEFPUSHBUTTON") != -1 || string.indexOf("GROUPBOX") != -1
					|| string.indexOf("ICON") != -1 || string.indexOf("LISTBOX") != -1 || string.indexOf("LTEXT") != -1
					|| string.indexOf("PUSHBOX") != -1 || string.indexOf("PUSHBUTTON") != -1
					|| string.indexOf("RADIOBUTTON") != -1 || string.indexOf("RTEXT") != -1
					|| string.indexOf("SCROLLBAR") != -1 || string.indexOf("STATE3") != -1) {
				return RC;
			}
			if (string.charAt(0) == '<') {
				SAXBuilder builder = new SAXBuilder();
				builder.setValidating(false);
				builder.build(file);
				return XML;
			}
			if (string.indexOf(" --> ") != -1 && string.indexOf(':') != -1) {
				return SRT;
			}
			if (string.indexOf('{') != -1 && string.indexOf(':') != -1 && loadJSON(file) != null) {
				return JSON;
			}
		} catch (Exception e) {
			// do nothing
		}
		if (fileName.endsWith(".properties")) {
			return JAVA;
		}
		if (fileName.toLowerCase().endsWith(".rc")) {
			return RC;
		}
		return null;
	}

	public static String getShortName(String type) {
		if (type == null) {
			return null;
		}
		if (type.equals(INX)) {
			return "INX";
		}
		if (type.equals(ICML)) {
			return "ICML";
		}
		if (type.equals(IDML)) {
			return "IDML";
		}
		if (type.equals(DITA)) {
			return "DITA";
		}
		if (type.equals(HTML)) {
			return "HTML";
		}
		if (type.equals(JS)) {
			return "JS";
		}
		if (type.equals(JSON)) {
			return "JSON";
		}
		if (type.equals(JAVA)) {
			return "JAVA";
		}
		if (type.equals(MIF)) {
			return "MIF";
		}
		if (type.equals(OFF)) {
			return "OFF";
		}
		if (type.equals(OO)) {
			return "OO";
		}
		if (type.equals(TEXT)) {
			return "TEXT";
		}
		if (type.equals(PO)) {
			return "PO";
		}
		if (type.equals(RC)) {
			return "RC";
		}
		if (type.equals(RESX)) {
			return "RESX";
		}
		if (type.equals(SDLPPX)) {
			return "SDLPPX";
		}
		if (type.equals(SDLXLIFF)) {
			return "SDLXLIFF";
		}
		if (type.equals(SRT)) {
			return "SRT";
		}
		if (type.equals(TS)) {
			return "TS";
		}
		if (type.equals(TXML)) {
			return "TXML";
		}
		if (type.equals(WPML)) {
			return "WPML";
		}
		if (type.equals(XLIFF)) {
			return "XLIFF";
		}
		if (type.equals(XML)) {
			return "XML";
		}
		if (type.equals(XMLG)) {
			return "XMLG";
		}
		return null;
	}

	public static String getFullName(String dataType) {
		if (dataType.equals("INX") || dataType.equals("x-inx")) {
			return INX;
		} else if (dataType.equals("ICML") || dataType.equals("x-icml")) {
			return ICML;
		} else if (dataType.equals("IDML") || dataType.equals("x-idml")) {
			return IDML;
		} else if (dataType.equals("DITA") || dataType.equals("x-ditamap")) {
			return DITA;
		} else if (dataType.equals("HTML") || dataType.equals("html")) {
			return HTML;
		} else if (dataType.equals("JS") || dataType.equals("javascript")) {
			return JS;
		} else if (dataType.equals("JSON") || dataType.equals("json")) {
			return JSON;
		} else if (dataType.equals("JAVA") || dataType.equals("javapropertyresourcebundle")
				|| dataType.equals("javalistresourcebundle")) {
			return JAVA;
		} else if (dataType.equals("MIF") || dataType.equals("mif")) {
			return MIF;
		} else if (dataType.equals("OFF") || dataType.equals("x-office")) {
			return OFF;
		} else if (dataType.equals("OO")) {
			return OO;
		} else if (dataType.equals("TEXT") || dataType.equals("plaintext")) {
			return TEXT;
		} else if (dataType.equals("PO") || dataType.equals("po")) {
			return PO;
		} else if (dataType.equals("RC") || dataType.equals("winres")) {
			return RC;
		} else if (dataType.equals("RESX") || dataType.equals("resx")) {
			return RESX;
		} else if (dataType.equals("SDLPPX") || dataType.equals("x-sdlpackage")) {
			return SDLPPX;
		} else if (dataType.equals("SDLXLIFF") || dataType.equals("x-sdlxliff")) {
			return SDLXLIFF;
		} else if (dataType.equals("SRT") || dataType.equals("x-srt")) {
			return SRT;
		} else if (dataType.equals("TS") || dataType.equals("x-ts")) {
			return TS;
		} else if (dataType.equals("TXML") || dataType.equals("x-txml")) {
			return TXML;
		} else if (dataType.equals("WPML") || dataType.equals("x-wpmlxliff")) {
			return WPML;
		} else if (dataType.equals("XLIFF") || dataType.equals("x-xliff")) {
			return XLIFF;
		} else if (dataType.equals("XML") || dataType.equals("xml")) {
			return XML;
		} else if (dataType.equals("XMLG")) {
			return XMLG;
		}
		return null;
	}

	private static boolean parseXliff(String file) {
		try {
			SAXBuilder builder = new SAXBuilder();
			Document doc = builder.build(file);
			return doc.getRootElement().getName().equals("xliff");
		} catch (SAXException | IOException | ParserConfigurationException e) {
			return false;
		}
	}

	public static String[] getFormats() {
		return formats;
	}

	private static JSONObject loadJSON(File file) throws IOException {
		StringBuilder sb = new StringBuilder();
		try (FileReader reader = new FileReader(file)) {
			try (BufferedReader buffered = new BufferedReader(reader)) {
				String line = "";
				while ((line = buffered.readLine()) != null) {
					sb.append(line);
				}
			}
		}
		return new JSONObject(sb.toString());
	}
}
